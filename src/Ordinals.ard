\import Logic
\import Order.LinearOrder
\import Paths
\import Prelude
\open Nat

{-------------------}

\data Unit | unit

\data Comp | LT | EQ | GT

\func Pos => \Sigma (p : Nat) (1 <= p)

\func psuc (n : Nat) : Pos => (suc n, suc<=suc zero<=_)

\func pone : Pos => psuc 0

\func id {A : \Type} (a : A) : A => a

{-------------------}

-- Not necessarily well-formed

\data Ord'
  | zero
  | ord Ord' Pos Ord' -- ord a n b := Ï‰^a * n + b
  \where {
    \data \infix 4 < Ord' Ord' \with
      | zero, ord _ _ _ => zero<_
      | ord a1 _ _, ord a2 _ _ => a1<a2 (a1 < a2)
      | ord a1 n1 _, ord a2 n2 _ => n1<n2 (a1 = a2) (suc n1.1 <= n2.1)
      | ord a1 n1 b1, ord a2 n2 b2 => b1<b2 (a1 = a2) (n1 = n2) (b1 < b2)

    \data wf Ord' \with
      | zero => wf0
      | ord a n zero => wfa0 (wf a)
      | ord a n (ord b m c) => wfab (wf a) (wf (ord b m c)) (b < a)

    \func size' (_ : Ord') : Nat \with
      | zero => 0
      | ord a n b => (size' a) + n.1 + (size' b)

    \use \coerce n2o' (n : Nat) : Ord' \with
      | 0 => zero
      | suc n => ord zero (psuc n) zero

    \func one' => n2o' 1

    \func w' => ord one' (psuc 0) zero

    \func osuc' (_ : Ord') : Ord' \with
      | zero => one'
      | ord zero n zero => n2o' (suc n.1)
--      | ord (ord a n b) m zero => ord (ord a n b) m one'
      | ord a n b => ord a n (osuc' b)
  }

\open Ord'

{-----------------}

-- Ordinals in Cantor Normal Form

\func Ord => \Sigma (x : Ord') (wf x)

\func size (x : Ord) : Nat => size' x.1

\func n2o (_ : Nat) : Ord \with
  | 0 => (zero, wf0)
  | suc n => (n2o' (suc n), wfa0 wf0)

\func one : Ord => n2o 1

\func w : Ord => (ord one.1 pone zero, wfa0 one.2)

\func zero!=osuc' {x : Ord'} (p : zero = osuc' x) : Empty \elim x
  | zero => transport T p unit
  | ord zero _ zero => transport T p unit
  | ord zero _ (ord _ _ _) => transport T p unit
  | ord (ord _ _ _) _ zero => transport T p unit
  | ord (ord _ _ _) _ (ord _ _ _) => transport T p unit
  \where {
    \func T (n : Ord') : \Type \with { | zero => Unit | _ => Empty }
  }

\func _!<zero {x : Ord'} (p : x < zero) : Empty \elim x, p

\func wfosuc' (x : Ord') (p : wf x) : (wf (osuc' x)) \with
  | zero, _ => one.2
  | ord zero n zero, _ => wfa0 wf0
  | ord zero n (ord a m b), wfab _ _ a<zero => absurd (_!<zero a<zero)
  | ord (ord a n b) m zero, wfa0 wfanb => wfab wfanb (wfa0 wf0) zero<_
--  | ord (ord a _ b) _ (ord c _ zero), wfab wfa_b wfc_z c<a_b =>
--    wfab wfa_b {?} {?}
--  | ord (ord a n b) m (ord a2 p (ord o p1 o1)), p2 => {?}

  | ord (ord a1 n1 b1) m (ord a2 n2 b2), wfab wfanb1 wfanb2 a2<anb1 =>
    \let
      | rec => wfosuc' (ord a2 n2 b2) wfanb2
    \in wfab wfanb1 {?} {?}

-- TODO: need to show that osuc' (ord a n b) = osuc' (ord a m c), i.e. a is unchanged
--       maybe just do more cases?

\func osuc (x : Ord) : Ord => (osuc' x.1, wfosuc' x.1 x.2)

--\func osuc (_ : Ord) : Ord \with
--  | (zero, _) => one
--  | (ord zero n zero, _) => n2o (suc n.1)
--  | (ord (ord a n b) m zero, wfa0 wfa) =>
--    (ord (ord a n b) n one.1, wfab wfa one.2 zero<_)
--  | (ord a n (ord b m c), wfab wfa wfbmc b<a) =>
--    \case osuc (ord b m c, wfbmc) \with {
--      | (zero, _) => (ord a n zero, wfa0 wfa)  -- FIXME: this can't happen though
--      | (ord b2 m2 c2, p) => (ord a n (ord b2 m2 c2), wfab wfa p {?})
--    }

--    \let
--      | (ord b' n' c', _) => osuc (ord b m c, wfb)
--    \in (ord a n (ord b' n' c'))

--    (ord a n (osuc (ord b m c, wfb)).1, wfab wfa wfb b<a)

{-------------------}









{-------------------}

-- TODO: osuc
-- TODO: arithmetic
-- TODO: encapsulate well-formedness into Ord without Ord'
-- TODO: parameterize Ordinal type over other monoids (not just Nat)
-- TODO: implement some type classes
-- TODO: specify and implement quasigroup typeclass










