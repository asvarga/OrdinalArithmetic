\import util
\import Logic
\import Order.LinearOrder
\import Paths
\import Prelude
\open Nat

{-------------------}

-- Positive Nats

\func Pos => \Sigma (p : Nat) (1 <= p)

\func psuc (n : Nat) : Pos => (suc n, suc<=suc zero<=_)

\func +1 => psuc 0

{-------------------}

-- Not necessarily well-formed

\data Ord'
  | zero
  | ord Ord' Pos Ord' -- ord a n b := Ï‰^a * n + b
  \where {
    \data \infix 4 < Ord' Ord' \with
      | zero, ord _ _ _ => zero<_
      | ord a1 _ _, ord a2 _ _ => a1<a2 (a1 < a2)
      | ord a1 n1 _, ord a2 n2 _ => n1<n2 (a1 = a2) (suc n1.1 <= n2.1)
      | ord a1 n1 b1, ord a2 n2 b2 => b1<b2 (a1 = a2) (n1 = n2) (b1 < b2)

    \func size' (_ : Ord') : Nat \with
      | zero => 0
      | ord a n b => size' a + n.1 + size' b

    \use \coerce n2o' (_ : Nat) : Ord' \with
      | 0 => zero
      | suc n => ord zero (psuc n) zero

    \func _!<zero {x : Ord'} (p : x < zero) : Empty \elim x, p
  }

\open Ord'

{-------------------}

-- Ordinals in Cantor Normal Form

\record Ord
  | val : Ord'
  | nfval : nf val
  \where {
    \data nf Ord' \with
      | zero => nf0
      | ord a n zero => nf1 (nf a)
      | ord a n (ord b m c) => nf2 (nf a) (nf (ord b m c)) (b < a)

    \func size (x : Ord) : Nat => size' x.val

    \use \coerce n2o (n : Nat) : Ord \with
      | 0 => \new Ord 0 nf0
      | suc n => \new Ord (suc n) (nf1 nf0)

    \func one : Ord => 1

    \func w : Ord \cowith
      | val => ord 1 +1 0
      | nfval => nf1 one.nfval

    \func osuc (x : Ord) : Ord \cowith
      | val => osuc' x.val
      | nfval => nfosuc x.nfval
      \where {
        \func osuc' (_ : Ord') : Ord' \with
          | zero => 1
          | ord zero n b => n2o' $ suc n.1
          | ord a n b => ord a n $ osuc' b

        \func nfosuc {x : Ord'} (p : nf x) : nf $ osuc' x \elim x, p
          | zero, _ => nf1 nf0
          | ord zero _ zero, _ => nf1 nf0
          | ord zero _ (ord _ _ _), nf2 _ _ a<zero => absurd $ _!<zero a<zero
          | ord (ord _ _ _) _ zero, nf1 nfa => nf2 nfa (nf1 nf0) zero<_
          | ord (ord _ _ _) _ (ord zero _ _), nf2 nfa _ _ => nf2 nfa (nf1 nf0) zero<_
          | ord (ord _ _ _) _ (ord (ord _ _ _) _ _), nf2 nfa nfb ba<a => nf2 nfa (nfosuc nfb) ba<a
      }
  }

\open Ord

{-------------------}

-- TODO: specify ploop (partial loop) typeclass
-- TODO: +
-- TODO: implement monoid (prove associativity)
-- TODO: left subtraction (total)
-- TODO: right subtraction (partial; need failure object)
-- TODO: implement ploop
-- TODO: encapsulate well-formedness into Ord without Ord'










